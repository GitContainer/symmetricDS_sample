<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Manage</title><link rel="stylesheet" href="css/docbook-style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="user-guide.html" title="SymmetricDS User Guide"><link rel="up" href="user-guide.html" title="SymmetricDS User Guide"><link rel="prev" href="config.html" title="Chapter&nbsp;3.&nbsp;Configuration"><link rel="next" href="advanced.html" title="Chapter&nbsp;5.&nbsp;Advanced Topics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="banner"><a style="border:none;" href="http://www.symmetricds.org/" title="SymmetricDS User Guide"><img style="border:none;" alt="SymmetricDS" src="images/banner-logo.gif"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="manage"></a>Chapter&nbsp;4.&nbsp;Manage</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="manage.html#identifying-nodes">4.1. Identifying Nodes</a></span></dt><dt><span class="section"><a href="manage.html#create-nodes">4.2. Creating Nodes</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#manage-node-registration">4.2.1. Registration</a></span></dt><dt><span class="section"><a href="manage.html#manage-node-initial-load">4.2.2. Initial Loads</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#configuration-initial-load-options">4.2.2.1. Target table prep for initial load</a></span></dt><dt><span class="section"><a href="manage.html#configuration-initial-load-select">4.2.2.2. Loading subsets of data</a></span></dt><dt><span class="section"><a href="manage.html#configuration-initial-load-batches">4.2.2.3. Splitting an Initial Load for a Table Across Multiple Batches</a></span></dt><dt><span class="section"><a href="manage.html#configuration-initial-load-reverse">4.2.2.4. Reverse Initial Loads</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#resync-data">4.2.3. Data Reloads</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#manage-jobs">4.3. Jobs</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#routing-job">4.3.1. Route Job</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#data-gaps">4.3.1.1. Data Gaps</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#push-pull-job">4.3.2. Push and Pull Jobs for Database changes</a></span></dt><dt><span class="section"><a href="manage.html#file-sync-push-pull">4.3.3. File Sync Push and Pull Jobs</a></span></dt><dt><span class="section"><a href="manage.html#file-sync-tracker-job">4.3.4. File System Tracker Job</a></span></dt><dt><span class="section"><a href="manage.html#sync-triggers">4.3.5. Sync Triggers Job</a></span></dt><dt><span class="section"><a href="manage.html#purge-job">4.3.6. Purge Jobs</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#manage-outgoing-batches">4.4. Outgoing Batches</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#manage-outgoing-batches-solving-issues">4.4.1. Analyzing the Issue</a></span></dt><dt><span class="section"><a href="manage.html#manage-outgoing-batches-resolving-issues">4.4.2. Resolving the Issue</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#manage-incoming-batches">4.5. Incoming Batches</a></span></dt><dd><dl><dt><span class="section"><a href="manage.html#manage-incoming-batches-solving-issues">4.5.1. Analyzing the Issue</a></span></dt><dt><span class="section"><a href="manage.html#manage-incoming-batches-resolving-issues">4.5.2. Resolving the Issue</a></span></dt></dl></dd><dt><span class="section"><a href="manage.html#manage-staging-area">4.6. Staging Area</a></span></dt><dt><span class="section"><a href="manage.html#manage-logging">4.7. Logging</a></span></dt></dl></div>
	
	
	
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifying-nodes"></a>4.1.&nbsp;Identifying Nodes</h2></div></div></div>
        
        <p>
            A
            <span class="emphasis"><em>node</em></span>
            is a single instance of SymmetricDS. It can be thought of as a proxy for a database which manages the
            synchronization of data to and/or from its database. For our example retail application, the following would be
            SymmetricDS nodes:
            </p><div class="itemizedlist"><ul type="disc"><li>Each point-of-sale workstation.</li><li>The central office database server.</li></ul></div><p>
            Each node of SymmetricDS can be either embedded in another application, run stand-alone, or even run in the
            background as a service. If desired, nodes can be clustered to help disperse load if they send and/or receive
            large volumes of data to or from a large number of nodes.
        </p>
        <p> Individual nodes are easy to identify when planning your implementation. If a database exists in your domain
            that needs to send or receive data, there needs to be a corresponding SymmetricDS instance (a node) responsible
            for managing the synchronization for that database.
        </p>
        
    </div>
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="create-nodes"></a>4.2.&nbsp;Creating Nodes</h2></div></div></div>
	
		<p>Nodes are defined in the
		<a href="data-model.html#table_node" title="A.17.&nbsp;NODE">NODE</a>
		table. Two other tables play a direct role in defining a node, as well
		The first is
		<a href="data-model.html#table_node_identity" title="A.27.&nbsp;NODE_IDENTITY">NODE_IDENTITY</a>
		. The
		<span class="emphasis"><em>only</em></span>
		row in this table is inserted in the database when the node first
		<span class="emphasis"><em>registers</em></span>
		with a parent node. In the case of a root node, the row is entered by
		the user. The row is used by a node instance to determine its node
		identity.
		</p>
		
		<p>
		The following SQL statements set up a top-level registration server as a
		node identified as "00000" in the "corp" node group.
		</p><pre class="programlisting"> insert into SYM_NODE (node_id,
		node_group_id, external_id, sync_enabled) values ('00000', 'corp',
		'00000', 1); insert into SYM_NODE_IDENTITY values ('00000');</pre><p>
		</p>
		
		<p>
		The second table,
		<a href="data-model.html#table_node_security" title="A.28.&nbsp;NODE_SECURITY">NODE_SECURITY</a>
		has rows created for each
		<span class="emphasis"><em>child</em></span>
		node that registers with the node, assuming auto-registration is
		enabled. If auto registration is not enabled, you must create a row in
		<a href="data-model.html#table_node" title="A.17.&nbsp;NODE">NODE</a>
		and
		<a href="data-model.html#table_node_security" title="A.28.&nbsp;NODE_SECURITY">NODE_SECURITY</a>
		for the node to be able to register. You can also, with this table,
		manually cause a node to re-register or do a re-initial load by setting
		the corresponding columns in the table itself. 
		</p>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-node-registration"></a>4.2.1.&nbsp;Registration</h3></div></div></div>
			
			<p>
			Node registration is the act of setting up a new
			<a href="data-model.html#table_node" title="A.17.&nbsp;NODE">NODE</a>
			and
			<a href="data-model.html#table_node_security" title="A.28.&nbsp;NODE_SECURITY">NODE_SECURITY</a>
			so that when the new node is brought online it is allowed to join the
			system. Nodes are only allowed to register if rows exist for the node
			and the
			<code class="literal">registration_enabled</code>
			flag is set to 1. If the
			<code class="literal">auto.registration</code>
			SymmetricDS property is set to true, then when a node attempts to
			register, if registration has not already occurred, the node will
			automatically be registered.
			</p>
			
			<p>
			SymmetricDS allows you to have multiple nodes with the same
			<code class="literal">external_id</code>
			. Out of the box, openRegistration will open a new registration if a
			registration already exists for a node with the same external_id. A new
			registration means a new node with a new
			<code class="literal">node_id</code>
			and the same
			<code class="literal">external_id</code>
			will be created. If you want to re-register the same node you can use
			the
			<code class="literal">reOpenRegistration()</code>
			JMX method which takes a
			<code class="literal">node_id</code>
			as an argument.
			</p>
		</div>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-node-initial-load"></a>4.2.2.&nbsp;Initial Loads</h3></div></div></div>

			
			
			<p>An initial load is the process of seeding tables at a
			target node with data from its parent node. When a node connects and
			data is extracted, after it is registered and if an initial load was
			requested, each table that is configured to synchronize to the target
			node group will be given a reload event in the order defined by the end
			user. A SQL statement is run against each table to get the data load
			that will be streamed to the target node. The selected data is filtered
			through the configured router for the table being loaded. If the data
			set is going to be large, then SQL criteria can optionally be provided
			to pare down the data that is selected out of the database.</p>
			
			<p>
			An initial load cannot occur until after a node is registered. An
			initial load is requested by setting the
			<code class="literal">initial_load_enabled</code>
			column on
			<a href="data-model.html#table_node_security" title="A.28.&nbsp;NODE_SECURITY">NODE_SECURITY</a>
			to
			<span class="emphasis"><em>1</em></span>
			on the row for the target node in the parent node's database. You can
			configure SymmetricDS to automatically perform an initial load when a
			node registers by setting the parameter
			<code class="literal">auto.reload</code>
			to true. Regardless of how the initial load is initiated, the next time
			the source node routes data, reload batches will be inserted. At the
			same time reload batches are inserted, all previously pending batches
			for the node are marked as successfully sent.
			</p>
			
			<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
			<p>
			Note that if the parent node that a node is registering with is
			<span class="emphasis"><em>not</em></span>
			a registration server node (as can happen with a registration redirect
			or certain non-tree structure node configurations) the parent node's
			<a href="data-model.html#table_node_security" title="A.28.&nbsp;NODE_SECURITY">NODE_SECURITY</a>
			entry must exist at the parent node and have a non-null value for column
			<code class="literal">initial_load_time</code>
			. Nodes can't be registered to non-registration-server nodes without
			this value being set one way or another (i.e., manually, or as a result
			of an initial load occurring at the parent node).
			</p>
			</div>
			
			<p>
			SymmetricDS recognizes that an initial load has completed when the
			<code class="literal">initial_load_time</code>
			column on the target node is set to a non-null value.
			</p>
			
			<p>
			An initial load is accomplished by inserting reload batches in a defined
			order according to the
			<code class="literal">initial_load_order</code>
			column on
			<a href="data-model.html#table_trigger_router" title="A.40.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>
			. If the
			<code class="literal">initial_load_order</code>
			column contains a negative value the associated table will
			<span class="emphasis"><em>NOT</em></span>
			be loaded. If the
			<code class="literal">initial_load_order</code>
			column contains the same value for multiple tables, SymmetricDS will
			attempt to order the tables according to foreign key constraints. If
			there are cyclical constraints, then foreign keys might need to be
			turned off or the initial load will need to be manually configured based
			on knowledge of how the data is structured.
			</p>
			
			<p>Initial load data is always queried from the source
			database table. All data is passed through the configured router to
			filter out data that might not be targeted at a node.</p>
			
			<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load-options"></a>4.2.2.1.&nbsp;Target table prep for initial load</h4></div></div></div>
			
			<p>There are several parameters that can be used to specify
			what, if anything, should be done to the table on the target database
			just prior to loading the data. Note that the parameters below specify
			the desired behavior for all tables in the initial load, not just one. </p>
			<div class="itemizedlist"><ul type="disc"><li>
			<code class="literal">initial.load.delete.first /
			initial.load.delete.first.sql</code>
			<p>
			By default, an initial load will not delete existing rows from a target
			table before loading the data. If a delete is desired, the parameter
			<code class="literal">initial.load.delete.first</code>
			can be set to true. If true, the command found in
			<code class="literal">initial.load.delete.first.sql</code>
			will be run on each table prior to loading the data. The default value
			for
			<code class="literal">initial.load.delete.first.sql</code>
			is
			<code class="literal">delete from %s</code>
			, but could be changed if needed. Note that additional reload batches
			are created, in the correct order, to achieve the delete.
			</p>
			</li><li>
			<code class="literal">initial.load.create.first</code>
			<p>
			By default, an initial load will not create the table on the target if
			it doesn't alleady exist. If the desired behavior is to create the table
			on the target if it is not present, set the parameter
			<code class="literal">intial.load.create.first</code>
			to true. SymmetricDS will attempt to create the table and indexes on the
			target database before doing the initial load. (Additional batches are
			created to represent the table schema).
			</p>
			</li></ul></div>
			</div>
			<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load-select"></a>4.2.2.2.&nbsp;Loading subsets of data</h4></div></div></div>
			
			
			<p>
			An efficient way to select a subset of data from a table for an initial
			load is to provide an
			<code class="literal">initial_load_select</code>
			clause on
			<a href="data-model.html#table_trigger_router" title="A.40.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>
			. This clause, if present, is applied as a
			<code class="literal">where</code>
			clause to the SQL used to select the data to be loaded. The clause may
			use "t" as an alias for the table being loaded, if needed. The
			<code class="literal">$(externalId)</code>
			token can be used for subsetting the data in the where clause.
			</p>
			
			<p>
			In cases where routing is done using a feature like
			<a href="config.html#configuration-subselect-router" title="3.6.4.&nbsp;Subselect Router">Section&nbsp;3.6.4, &#8220;Subselect Router&#8221;</a>
			, an
			<code class="literal">initial_load_select</code>
			clause matching the subselect's criteria would be a more efficient
			approach. Some routers will check to see if the
			<code class="literal">initial_load_select</code>
			clause is provided, and they will
			<span class="emphasis"><em>not</em></span>
			execute assuming that the more optimal path is using the
			<code class="literal">initial_load_select</code>
			statement.
			</p>
			
			<p>
			One example of the use of an initial load select would be if you wished
			to only load data created more recently than the start of year 2011.
			Say, for example, the column
			<code class="literal">created_time</code>
			contains the creation date. Your
			<code class="literal">initial_load_select</code>
			would read
			<code class="literal">created_time &gt; ts {'2011-01-01 00:00:00.0000'}</code>
			(using whatever timestamp format works for your database). This then
			gets applied as a
			<code class="literal">where</code>
			clause when selecting data from the table.
			</p>
			
			<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
			<p>
			When providing an
			<code class="literal">initial_load_select</code>
			be sure to test out the criteria against production data in a query
			browser. Do an explain plan to make sure you are properly using indexes.
			</p>
			</div>
			</div>
			
			<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load-batches"></a>4.2.2.3.&nbsp;Splitting an Initial Load for a Table Across Multiple Batches</h4></div></div></div>
			
			<p>
			By default, all data for a given table will be initial loaded in a single batch, regardless
			of the max batch size parameter on the reload channel.  That is, for a table with one million
			rows, all rows for that table will be initial loaded and sent to the destination node in a
			single batch. For large tables, this can result in a batch that can take a long time to
			extract and load.
			</p>
			
			<p>
			Initial loads for a table can be broken into multiple batches by specifying
			<code class="literal">initial.load.use.extract.job.enabled</code> to true.  This parameter allows
			SymmetricDS to pre-extract initial load batches versus having them extracted when
			the batch is pulled or pushed.  When using this parameter, there are two ways to tell
			SymmetricDS the number of batches to create for a given table.  The first is to specify
			a positive integer in the initial_load_batch_count column on
			<a href="data-model.html#table_trigger_router" title="A.40.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.  This
			number will dictate the number of batches created for the initial load of the given table.
			The second way is to specify 0 for initial_load_batch_count on
			<a href="data-model.html#table_trigger_router" title="A.40.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a> and
			specify a max_batch_size on the reload channel in <a href="data-model.html#table_channel" title="A.1.&nbsp;CHANNEL">CHANNEL</a>.
			When 0 is specified for
			initial_load_batch_count, SymmetricDS will execute a count(*) query on the table during
			the extract process and create N batches based on the total number of records found
			in the table divided by the max_batch_size on the reload channel.
			</p>
			
			</div>
			
			<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load-reverse"></a>4.2.2.4.&nbsp;Reverse Initial Loads</h4></div></div></div>
			
			<p>
			The default behavior for initial loads is to load data from the
			registration server or parent node, to a client node. Occasionally,
			there may be need to do a one-time intial load of data in the opposite
			or "reverse" direction, namely from a client node to the registration
			node. To achieve this, set the parameter
			<code class="literal">auto.reload.reverse</code>
			to be true,
			<span class="emphasis"><em>but only for the specific node group representing
			the client nodes</em></span>
			. This will cause a onetime reverse load of data, for tables configured
			with non-negative initial load orders, to be batched at the point when
			registration of the client node is occurring. These batches are then
			sent to the parent or registration node. This capability might be
			needed, for example, if there is data already present in the client that
			doesn't exist in the parent but needs to.
			</p>
			</div>
		</div>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resync-data"></a>4.2.3.&nbsp;Data Reloads</h3></div></div></div>
	        
	        <p>
	        There may be times where you find you need to re-send or re-synchronize data when the change itself was not captured.  This could be needed, for example,
	        if the data changes occurred prior to SymmetricDS placing triggers on the data tables themselves, or if the data at the destination was accidentally deleted, or for
	        some other reason.  Two approaches are commonly taken to re-send the data, both of which are discussed below.
	        </p>
	
	      <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
	            <p>Be careful when re-sending data using either of these two techniques.  Be sure you are only sending the rows you intend to send and,
	            more importantly, be sure to re-send the data in a way that won't cause foreign key constraint issues at the destination.  In other words,
	            if more than one table is involved, be sure to send any tables which are referred to by other tables by foreign keys first.  Otherwise,
	            the channel's synchronization will block because SymmetricDS is unable to insert or update the row because the foreign key relationship refers to
	            a non-existent row in the destination!
	           </p>
	      </div>
	
	        <p>One possible approach would be to "touch" the rows in individual tables that need re-sent.  By "touch", we mean to alter the row data in such a way
	        that SymmetricDS detects a data change and therefore includes the data change in the batching and synchronizing steps.  Note that you have to
	        change the data in some meaningful way (e.g., update a time stamp); setting a column to its current value is not sufficient (by default, if there's not an actual data
	        value change SymmetricDS won't treat the change as something which needs synched.
	        </p>
	        <p>A second approach would be to take advantage of SymmetricDS built-in functionality by simulating a partial "initial load" of the data.  The approach
	        is to manually create "reload" events in <a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a> for the necessary tables, thereby resending the desired rows for the given tables.
	        Again, foreign key constraints must be kept in mind when creating these reload events.  These reload events are created in the source database itself, and
	        the necessary table, trigger-router combination, and channel are included to indicate the direction of synchronization.</p>
	        <p>
	        To create a reload event, you create a <a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a> row, using:
	       </p><div class="itemizedlist"><ul type="disc"><li>data_id:  null</li><li>table_name:  name of table to be sent</li><li>event_type: 'R', for reload</li><li>row_data:  a "where" clause (minus the word 'where') which defines the subset of rows from the table to be sent.  To send all rows, one can use 1=1 for this value.</li><li>pk_data:  null</li><li>old_data: null</li><li>trigger_hist_id:  use the id of the most recent entry (i.e., max(trigger_hist_id) ) in <a href="data-model.html#table_trigger_hist" title="A.39.&nbsp;TRIGGER_HIST">TRIGGER_HIST</a>
	        for the trigger-router combination for your table and router.</li><li>channel_id:  the channel in which the table is routed</li><li>transaction_id:  pick a value, for example '1'</li><li>source_node_id: null</li><li>external_data: null</li><li>create_time:  current_timestamp</li></ul></div><p>
	        </p>
	
	        <p>
	        Let's say we need to re-send a particular sales transaction from the store to corp over again because we lost the data in corp due to
	        an overzealous delete.  For the tutorial, all transaction-related tables start with <code class="literal">sale_</code>,
	        use the <code class="literal">sale_transaction</code> channel, and are routed using the <code class="literal">store_corp_identity</code>
	        router.  In addition, the trigger-routers have been set up with an initial load order based on the necessary
	        foreign key relationships (i.e., transaction tables which are "parents" have a lower initial load order than those of their
	        "children").  An insert statement that would create the necessary "reload" events (three in this case, one for each table) would be as follows
	        (where MISSING_ID is changed to the needed transaction id):
	       </p><pre class="programlisting">
	
	insert into sym_data (
	    select null, t.source_table_name, 'R', 'tran_id=''MISSING-ID''', null, null,
	            h.trigger_hist_id, t.channel_id, '1', null, null, current_timestamp
	        from sym_trigger t inner join sym_trigger_router tr on
	            t.trigger_id=tr.trigger_id inner join sym_trigger_hist h on
	            h.trigger_hist_id=(select max(trigger_hist_id) from sym_trigger_hist
	                where trigger_id=t.trigger_id)
	    where channel_id='sale_transaction' and
	        tr.router_id like 'store_corp_identity' and
	        (t.source_table_name like 'sale_%')
	    order by tr.initial_load_order asc);
	    </pre><p>
	
	    This insert statement generates three rows, one for each configured sale table.  It uses the most recent
	    trigger history id for the corresponding table.  It takes advantage of the initial load order for each trigger-router to
	    create the three rows in the correct order (the order corresponding to the order in which the tables would have been initial loaded).
	
	    </p>
	    </div>
	</div>
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manage-jobs"></a>4.3.&nbsp;Jobs</h2></div></div></div>
	
		<p>
		Work done by SymmetricDS is initiated by jobs. Jobs are tasks that are
		started and scheduled by a job manager. Jobs are enabled by the
		<code class="literal">start.{name}.job</code>
		property. Most jobs are enabled by default. The frequency at which a job
		runs in controlled by one of two properties:
		<code class="literal">job.{name}.period.time.ms</code>
		or
		<code class="literal">job.{name}.cron</code>
		. If a valid cron property exists in the configuration, then it will be
		used to schedule the job. Otherwise, the job manager will attempt to use
		the period.time.ms property.
		</p>
		<p>
		The frequency of jobs can be configured in either the engines properties
		file or in
		<a href="data-model.html#table_parameter" title="A.30.&nbsp;PARAMETER">PARAMETER</a>
		. When managed in
		<a href="data-model.html#table_parameter" title="A.30.&nbsp;PARAMETER">PARAMETER</a>
		the frequency properties can be changed in the registration server and
		when the updated settings sync to the nodes in the system the job
		manager will restart the jobs at the new frequency settings.
		</p>
		<p>
		SymmetricDS utilizes Spring's CRON support, which includes seconds as
		the first parameter. This differs from the typical Unix-based
		implementation, where the first parameter is usually minutes. For
		example,
		<code class="literal">*/15 * * * * *</code>
		means every 15 seconds, not every 15 minutes. See
		<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/scheduling/support/CronSequenceGenerator.html" target="_top">Spring's
		documentation</a>
		for more details.
		</p>
		<p>
		Some jobs cannot be run in parallel against a single node. When running
		on a cluster these jobs use the
		<a href="data-model.html#table_lock" title="A.16.&nbsp;LOCK">LOCK</a>
		table to get an exclusive semaphore to run the job. In order to use this
		table the
		<code class="literal">cluster.lock.enabled</code>
		must be set to true.
		</p>
		<p> The three main jobs in SymmetricDS are the route, push and
		pull jobs. The route job decides what captured data changes should be
		sent to which nodes. It also decides what captured data changes should
		be transported and loaded together in a batch. The push and pull jobs
		are responsible for initiating HTTP communication with linked nodes to
		push or pull data changes that have been routed. </p>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="routing-job"></a>4.3.1.&nbsp;Route Job</h3></div></div></div>
		
		<p>
		After data is captured in the
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		table, it is routed to specific nodes in batches by the
		<span class="emphasis"><em>Route Job</em></span>
		. It is a single background task that inserts into
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		and
		<a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
		.
		</p>
		<p>
		The job processes each enabled channel, one at a time, collecting a list
		of data ids from
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		which have not been routed (see
		<a href="manage.html#data-gaps" title="4.3.1.1.&nbsp;Data Gaps">Section&nbsp;4.3.1.1, &#8220;Data Gaps&#8221;</a>
		for much more detail about this step), up to a limit specified by the
		channel configuration (
		<code class="literal">max_data_to_route</code>
		, on
		<a href="data-model.html#table_channel" title="A.1.&nbsp;CHANNEL">CHANNEL</a>
		). The data is then batched based on the
		<code class="literal">batch_algorithm</code>
		defined for the channel. Note that, for the
		<code class="literal">default</code>
		and
		<code class="literal">transactional</code>
		algorithm, there may actually be more than
		<code class="literal">max_data_to_route</code>
		included depending on the transaction boundaries. The mapping of data to
		specific nodes, organized into batches, is then recorded in
		<a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
		with a status of "RT" in each case (representing the fact that the Route
		Job is still running). Once the routing algorithms and batching are
		completed, the batches are organized with their corresponding data ids
		and saved in
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		. Once
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		is updated, the rows in
		<a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
		are updated to a status of New "NE".
		</p>
		<p>
		The route job will respect the
		<code class="literal">max_batch_size</code>
		on
		<a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
		. If the max batch size is reached before the end of a database
		tranaction and the batch algorithm is set to something other than
		<code class="literal">nontransactional</code>
		the batch may exceed the specified max size.
		</p>
		<p>
		The route job delegates to a router defined by the
		<code class="literal">router_type</code>
		and configured by the
		<code class="literal">router_expression</code>
		in the
		<a href="data-model.html#table_router" title="A.33.&nbsp;ROUTER">ROUTER</a>
		table. Each router that has a
		<code class="literal">source_node_group_id</code>
		that matches the current node's source node group id and is linked to
		the
		<a href="data-model.html#table_trigger" title="A.38.&nbsp;TRIGGER">TRIGGER</a>
		that captured the data gets an opportunity to choose a list of nodes the
		data should be sent to. Data can only be routed to nodes that belong to
		the router's
		<code class="literal">target_node_group_id</code>
		.
		</p>
		<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="data-gaps"></a>4.3.1.1.&nbsp;Data Gaps</h4></div></div></div>
		
		<p>
		On the surface, the first Route Job step of collecting unrouted data ids
		seems simple: assign sequential data ids for each data row as it's
		inserted and keep track of which data id was last routed and start from
		there. The difficulty arises, however, due to the fact that there can be
		multiple transactions inserting into
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		simultaneously. As such, a given section of rows in the
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		table may actually contain "gaps" in the data ids when the Route Job is
		executing. Most of these gaps are only temporarily and fill in at some
		point after routing and need to be picked up with the next run of the
		Route Job. Thus, the Route Job needs to remember to route the filled-in
		gaps. Worse yet, some of these gaps are actually permanent and result
		from a transaction that is rolled back for some reason. In this case,
		the Route Job must continue to watch for the gap to fill in and, at some
		point, eventually gives up and assumes the gap is permanent and can be
		skipped. All of this must be done in some fashion that guarantees that
		gaps are routed when they fill in while also keeping routing as
		efficient as possible.
		</p>
		<p>
		SymmetricDS handles the issue of data gaps by making use of a table,
		<a href="data-model.html#table_data_gap" title="A.5.&nbsp;DATA_GAP">DATA_GAP</a>
		, to record gaps found in the data ids. In fact, this table completely
		defines the entire range of data tha can be routed at any point in time.
		For a brand new instance of SymmetricDS, this table is empty and
		SymmetricDS creates a gap starting from data id of zero and ending with
		a very large number (defined by
		<code class="literal">routing.largest.gap.size</code>
		). At the start of a Route Job, the list of valid gaps (gaps with status
		of 'GP') is collected, and each gap is evaluated in turn. If a gap is
		sufficiently old (as defined by
		<code class="literal">routing.stale.dataid.gap.time.ms</code>
		, the gap is marked as skipped (status of 'SK') and will no longer be
		evaluated in future Route Jobs (note that the 'last' gap (the one with
		the highest starting data id) is never skipped). If not skipped, then
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		is searched for data ids present in the gap. If one or more data ids is
		found in
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		, then the current gap is marked with a status of OK, and new gap(s) are
		created to represent the data ids still missing in the gap's range. This
		process is done for all gaps. If the very last gap contained data, a new
		gap starting from the highest data id and ending at (highest data id +
		<code class="literal">routing.largest.gap.size</code>
		) is then created. This process has resulted in an updated list of gaps
		which may contain new data to be routed.
		</p>
		</div>
		</div>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="push-pull-job"></a>4.3.2.&nbsp;Push and Pull Jobs for Database changes</h3></div></div></div>
		
		<p>
		After database-change data is routed, it awaits transport to the target nodes. Transport
		can occur when a client node is configured to pull data or when the host
		node is configured to push data. These events are controlled by the
		<span class="emphasis"><em>push</em></span>
		and the
		<span class="emphasis"><em>pull jobs</em></span>
		. When the
		<code class="literal">start.pull.job</code>
		SymmetricDS property is set to
		<code class="literal">true</code>
		, the frequency that data is pulled is controlled by the
		<code class="literal">job.pull.period.time.ms</code>
		. When the
		<code class="literal">start.push.job</code>
		SymmetricDS property is set to
		<code class="literal">true</code>
		, the frequency that data is pushed is controlled by the
		<code class="literal">job.push.period.time.ms</code>
		.
		</p>
		<p>
		Data is extracted by channel from the source database's
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		table at an interval controlled by the
		<code class="literal">extract_period_millis</code>
		column on the
		<a href="data-model.html#table_channel" title="A.1.&nbsp;CHANNEL">CHANNEL</a>
		table. The
		<code class="literal">last_extract_time</code>
		is always recorded, by channel, on the
		<a href="data-model.html#table_node_channel_ctl" title="A.19.&nbsp;NODE_CHANNEL_CTL">NODE_CHANNEL_CTL</a>
		table for the host node's id. When the Pull and Push Job run, if the
		extract period has not passed according to the last extract time, then
		the channel will be skipped for this run. If the
		<code class="literal">extract_period_millis</code>
		is set to zero, data extraction will happen every time the jobs run.
		</p>
		<p>
		The maximum number of batches to extract per synchronization is
		controlled by
		<code class="literal">max_batch_to_send</code>
		on the
		<a href="data-model.html#table_channel" title="A.1.&nbsp;CHANNEL">CHANNEL</a>
		table. There is also a setting that controls the max number of bytes to
		send in one synchronization. If SymmetricDS has extracted the more than
		the number of bytes configured by the
		<code class="literal">transport.max.bytes.to.sync</code>
		parameter, then it will finish extracting the current batch and finish
		synchronization so the client has a chance to process and acknowlege the
		"big" batch. This may happen before the configured max number of batches
		has been reached.
		</p>
		<p>
		Both the push and pull jobs can be configured to push and pull multiple
		nodes in parallel. In order to take advantage of this the
		<code class="literal">pull.thread.per.server.count</code>
		or
		<code class="literal">push.thread.per.server.count</code>
		should be adjusted (from their default value of 10) to the number to the
		number of concurrent push/pulls you want to occur per period on each
		SymmetricDS instance. Push and pull activity is recorded in the
		<a href="data-model.html#table_node_communication" title="A.18.&nbsp;NODE_COMMUNICATION">NODE_COMMUNICATION</a>
		table. This table is also used to lock push and pull activity across
		multiple servers in a cluster.
		</p>
		<p>
		SymmetricDS also provides the ability to configure windows of time when
		synchronization is allowed. This is done using the
		<a href="data-model.html#table_node_group_channel_wnd" title="A.21.&nbsp;NODE_GROUP_CHANNEL_WND">NODE_GROUP_CHANNEL_WND</a>
		table. A list of allowed time windows can be specified for a node group
		and a channel. If one or more windows exist, then data will only be
		extracted and transported if the time of day falls within the window of
		time specified. The configured times are always for the target node's
		local time. If the
		<code class="literal">start_time</code>
		is greater than the
		<code class="literal">end_time</code>
		, then the window crosses over to the next day.
		</p>
		<p>
		All data loading may be disabled by setting the
		<code class="literal">dataloader.enable</code>
		property to false. This has the effect of not allowing incoming
		synchronizations, while allowing outgoing synchronizations. All data
		extractions may be disabled by setting the
		<code class="literal">dataextractor.enable</code>
		property to false. These properties can be controlled by inserting into
		the root server's
		<a href="data-model.html#table_parameter" title="A.30.&nbsp;PARAMETER">PARAMETER</a>
		table. These properties affect every channel with the exception of the
		'config' channel.
		</p>
		<p> Node communication over HTTP is represented in the
		following figure. </p>
		<p>
		</p><div class="figure"><a name="d4e1219"></a><div class="figure-contents">
		
		<div class="mediaobject"><img src="./images/seq-node-communication.gif" alt="Node Communication"></div>
		</div><p class="title"><b>Figure&nbsp;4.1.&nbsp;Node Communication</b></p></div><p><br class="figure-break">
		</p>
		</div>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="file-sync-push-pull"></a>4.3.3.&nbsp;File Sync Push and Pull Jobs</h3></div></div></div>
		
		<p>
		The File Sync Push and Pull jobs (introduced in version 3.5) are responsible for synchronizing file changes.
		These jobs work with batches on the <code class="literal">filesync</code> channel and create ZIP files of changed files
		to be sent and applied on other nodes.
		The parameters <code class="literal">job.file.sync.push.period.time.ms</code> and <code class="literal">job.file.sync.pull.period.time.ms</code>
		control how often the jobs runs, which default to every 60 seconds.
		See also <a href="manage.html#manage-jobs" title="4.3.&nbsp;Jobs">Section&nbsp;4.3, &#8220;Jobs&#8221;</a> and <a href="config.html#filesync-operation" title="3.5.2.&nbsp;Operation">Section&nbsp;3.5.2, &#8220;Operation&#8221;</a>.
		</p>
		</div>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="file-sync-tracker-job"></a>4.3.4.&nbsp;File System Tracker Job</h3></div></div></div>
		
		<p>
		The File System Tracker job (introduced in version 3.5) is responsible for monitoring and
		recording the events of files being created, modified, or deleted.
		It records the current state of files to the <a href="data-model.html#table_file_snapshot" title="A.8.&nbsp;FILE_SNAPSHOT">FILE_SNAPSHOT</a> table.
		The parameter <code class="literal">job.file.sync.tracker.cron</code> controls how often the job runs,
		which defaults to every 5 minutes.
		See also <a href="manage.html#manage-jobs" title="4.3.&nbsp;Jobs">Section&nbsp;4.3, &#8220;Jobs&#8221;</a> and <a href="config.html#file-sync" title="3.5.&nbsp;File Triggers / File Synchronization">Section&nbsp;3.5, &#8220;File Triggers / File Synchronization&#8221;</a>.
		</p>
		</div>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sync-triggers"></a>4.3.5.&nbsp;Sync Triggers Job</h3></div></div></div>
		
		<p>
		SymmetricDS examines the current configuration, corresponding database
		triggers, and the underlying tables to determine if database triggers
		need created or updated. The change activity is recorded on the
		<a href="data-model.html#table_trigger_hist" title="A.39.&nbsp;TRIGGER_HIST">TRIGGER_HIST</a>
		table with a reason for the change. The following reasons for a change
		are possible:
		
		</p><div class="itemizedlist"><ul type="disc"><li>
		<p>N - New trigger that has not been created before</p>
		</li><li>
		<p>S - Schema changes in the table were detected</p>
		</li><li>
		<p>C - Configuration changes in Trigger</p>
		</li><li>
		<p>T - Trigger was missing</p>
		</li></ul></div><p>
		
		A configuration entry in Trigger without any history in Trigger Hist
		results in a new trigger being created (N). The Trigger Hist stores a
		hash of the underlying table, so any alteration to the table causes the
		trigger to be rebuilt (S). When the
		<code class="literal">last_update_time</code>
		is changed on the Trigger entry, the configuration change causes the
		trigger to be rebuilt (C). If an entry in Trigger Hist is missing the
		corresponding database trigger, the trigger is created (T).
		</p>
		<p>
		The process of examining triggers and rebuilding them is automatically
		run during startup and each night by the SyncTriggersJob. The user can
		also manually run the process at any time by invoking the
		<code class="literal">syncTriggers()</code>
		method over JMX.
		</p>
		</div>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="purge-job"></a>4.3.6.&nbsp;Purge Jobs</h3></div></div></div>
		
		<p>
		Purging is the act of cleaning up captured data that is no longer needed
		in SymmetricDS's runtime tables. Data is purged through delete
		statements by the
		<span class="emphasis"><em>Purge Job</em></span>
		. Only data that has been successfully synchronized will be purged.
		Purged tables include:
		</p><div class="itemizedlist"><ul type="disc"><li>
		<a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a>
		</li><li>
		<a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>
		</li><li>
		<a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
		</li><li>
		<a href="data-model.html#table_incoming_batch" title="A.13.&nbsp;INCOMING_BATCH">INCOMING_BATCH</a>
		</li><li>
		<a href="data-model.html#table_data_gap" title="A.5.&nbsp;DATA_GAP">DATA_GAP</a>
		</li><li>
		<a href="data-model.html#table_node_host_stats" title="A.26.&nbsp;NODE_HOST_STATS">NODE_HOST_STATS</a>
		</li><li>
		<a href="data-model.html#table_node_host_channel_stats" title="A.24.&nbsp;NODE_HOST_CHANNEL_STATS">NODE_HOST_CHANNEL_STATS</a>
		</li><li>
		<a href="data-model.html#table_node_host_job_stats" title="A.25.&nbsp;NODE_HOST_JOB_STATS">NODE_HOST_JOB_STATS</a>
		</li></ul></div><p>
		The purge job is enabled by the
		<code class="literal">start.purge.job</code>
		SymmetricDS property. The timing of the three purge jobs (incoming,
		outgoing, and data gaps) is controlled by a cron expression as specified
		by the following properties:
		<code class="literal">job.purge.outgoing.cron</code>
		,
		<code class="literal">job.purge.incoming.cron</code>
		, and
		<code class="literal">job.purge.datagaps.cron</code>
		. The default is
		<code class="literal">0 0 0 * * *</code>
		, or once per day at midnight.
		</p>
		
		<p>
		Two retention period properties indicate how much history SymmetricDS
		will retain before purging. The
		<code class="literal">purge.retention.minutes</code>
		property indicates the period of history to keep for synchronization
		tables. The default value is 5 days. The
		<code class="literal">statistic.retention.minutes</code>
		property indicates the period of history to keep for statistics. The
		default value is also 5 days.
		</p>
		<p> The purge properties should be adjusted according to how
		much data is flowing through the system and the amount of storage space
		the database has. For an initial deployment it is recommended that the
		purge properties be kept at the defaults, since it is often helpful to
		be able to look at the captured data in order to triage problems and
		profile the synchronization patterns. When scaling up to more nodes, it
		is recomended that the purge parameters be scaled back to 24 hours or
		less. </p>
	</div>
	</div>
	
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manage-outgoing-batches"></a>4.4.&nbsp;Outgoing Batches</h2></div></div></div>
		
		<p>
	       By design, whenever SymmetricDS encounters an issue with a synchronization, the batch containing the error is marked as being in
	       an error state, and all subsequent batches <span class="emphasis"><em>for that particular channel to that particular node</em></span> are held and not
	       synchronized until the error batch is resolved.  SymmetricDS will retry the batch in error until the situation creating the
	       error is resolved (or the data for the batch itself is changed).
	   </p>

       	<p>
       	Analyzing and resolving issues can take place on the outgoing or incoming side.  The techniques for analysis are slightly different in
       	the two cases, however, due to the fact that the node with outgoing batch data also has the data and data events associated with the batch in
       	the database.  On the incoming node, however, all that is available is the incoming batch header and data present in an incoming error table.
		</p>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-outgoing-batches-solving-issues"></a>4.4.1.&nbsp;Analyzing the Issue</h3></div></div></div>
        	

	       <p>
	       The first step in analyzing the cause of a failed batch is to locate information about the data in the batch, starting with
	       <a href="data-model.html#table_outgoing_batch" title="A.29.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
	       To locate batches in error, use:
	       </p><pre class="programlisting">select * from sym_outgoing_batch where error_flag=1;</pre><p>
	       Several useful pieces of information are available from this query:
	       </p><div class="itemizedlist"><ul type="disc"><li>
	       The batch number of the failed batch, available in column <code class="literal">BATCH_ID</code>.
	       </li><li>
	       The node to which the batch is being sent, available in column <code class="literal">NODE_ID</code>.
	       </li><li>
	       The channel to which the batch belongs, available in column <code class="literal">CHANNEL_ID</code>.
	       All subsequent batches on this channel to this node will be held until the error condition is resolved.
	       </li><li>
	       The specific data id in the batch which is causing the failure, available in column <code class="literal">FAILED_DATA_ID</code>.
	       </li><li>
	       Any SQL message, SQL State, and SQL Codes being returned during the synchronization attempt, available in columns <code class="literal">SQL_MESSAGE</code>,
	       <code class="literal">SQL_STATE</code>, and <code class="literal">SQL_CODE</code>, respectively.
	       </li></ul></div><p>
	       </p>
	       <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
	       Using the <code class="literal">error_flag</code> on the batch table, as shown above, is more reliable than using the
	       <code class="literal">status</code> column.  The status column can change from 'ER' to a different status temporarily as
	       the batch is retried.
	       </div>
	       <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The query above will also show you any recent batches that
	       were originally in error and were changed to be manually skipped.  See the end of  <a href="manage.html#manage-outgoing-batches-solving-issues" title="4.4.1.&nbsp;Analyzing the Issue">Section&nbsp;4.4.1, &#8220;Analyzing the Issue&#8221;</a> for more details.
	       </div>
	       <p>
	       To get a full picture of the batch, you can query for information representing the complete
	       list of all data changes associated with the failed batch by joining
	       <a href="data-model.html#table_data" title="A.3.&nbsp;DATA">DATA</a> and  <a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>, such as:
	       </p><pre class="programlisting">select * from sym_data where data_id in
	        (select data_id from sym_data_event where batch_id='XXXXXX');</pre><p>
	       where XXXXXX is the batch id of the failing batch.
	       </p>
	       <p>
	       This query returns a wealth of information about each data change in a batch, including:
	       </p><div class="itemizedlist"><ul type="disc"><li>
	       The table involved in each data change, available in column <code class="literal">TABLE_NAME</code>,</li><li>
	       The event type (Update [U], Insert [I], or Delete [D]), available in column <code class="literal">EVENT_TYPE</code>,
	       </li><li>
	       A comma separated list of the new data and (optionally) the old data, available in columns <code class="literal">ROW_DATA</code> and
	       <code class="literal">OLD_DATA</code>, respectively.
	       </li><li>
	       The primary key data, available in column <code class="literal">PK_DATA</code>
	       </li><li>
	       The channel id, trigger history information, transaction id if available, and other information.
	       </li></ul></div><p>
	       </p>
	       <p>
	       More importantly, if you narrow your query to just the failed data id you can determine the exact data change that is causing the failure:
	       </p><pre class="programlisting">select * from sym_data where data_id in
	        (select failed_data_id from sym_outgoing_batch where batch_id='XXXXX'
	        and node_id='YYYYY');</pre><p>
	       where XXXXXX is the batch id and YYYYY is the node id of the batch that is failing.
	       </p>
	       <p>The queries above usually yield enough information to be able to determine why a
	       particular batch is failing. Common reasons a batch might be failing include:
	            </p><div class="itemizedlist"><ul type="disc"><li>
	            The schema at the destination has a column that is not nullable yet the source
	            has the column defined as nullable and a data change was sent with the column as null.</li><li>
	            A foreign key constraint at the destination is preventing an insertion or update, which could be caused from
	            data being deleted at the destination or the foreign key constraint is not in place at the source.
	            </li><li>
	            The data size of a column on the destination is smaller than the data size in the source, and data that
	            is too large for the destination has been synced.
	            </li></ul></div><p>
            </p>
         </div>
         <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-outgoing-batches-resolving-issues"></a>4.4.2.&nbsp;Resolving the Issue</h3></div></div></div>
            

            <p>
            Once you have decided upon the cause of the issue, you'll have to decide the best course of action to fix the issue.  If, for example,
            the problem is due to a database schema mismatch, one possible solution would be to alter the destination database
            in such a way that the SQL error no longer occurs.  Whatever approach you take to remedy the issue, once you have
            made the change, on the next push or pull SymmetricDS will retry the batch
            and the channel's data will start flowing again.
            </p>
            <p>
            If you have instead decided that the batch itself is wrong, or does not need synchronized, or you wish to remove a
            particular data change from a batch, you do have the option of changing the data associated with the batch directly.

            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
            Be cautious when using the following two approaches to resolve synchronization issues.  By far, the
            best approach to solving a synchronization error is to resolve what is truly causing the
            error at the destination database.  Skipping a batch or removing a data id as discussed below should be your
            solution of last resort, since doing so results in differences between the source and destination databases.
            </div><p>

            Now that you've read the warning, if you <span class="emphasis"><em>still</em></span> want to change the batch
            data itself, you do have several options, including:
            </p><div class="itemizedlist"><ul type="disc"><li>Causing SymmetricDS to skip the batch completely.  This is accomplished by setting the
                batch's status to 'OK', as in:
                <pre class="programlisting">update sym_outgoing_batch set status='OK' where batch_id='XXXXXX'</pre>
                where XXXXXX is the failing batch. On the next pull or push, SymmetricDS will skip this batch since
                it now thinks the batch has already been synchronized.  Note that you can still distinguish between successful
                batches and ones that you've artificially marked as 'OK', since the <code class="literal">error_flag</code> column on
                the failed batch will still be set to '1' (in error).
                </li><li>
                Removing the failing data id from the batch by deleting the corresponding row in <a href="data-model.html#table_data_event" title="A.4.&nbsp;DATA_EVENT">DATA_EVENT</a>.
                Eliminating the data id from the list of data ids in the batch will cause future synchronization attempts
                of the batch to no longer include that particular data change as part of the batch.  For example:
                  <pre class="programlisting">delete from sym_data_event where batch_id='XXXXXX' and data_id='YYYYYY'</pre>
                where XXXXXX is the failing batch and YYYYYY is the data id to longer be included in the batch.
                </li></ul></div><p>
            </p>
   		</div>
         
    </div>
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manage-incoming-batches"></a>4.5.&nbsp;Incoming Batches</h2></div></div></div>
		
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-incoming-batches-solving-issues"></a>4.5.1.&nbsp;Analyzing the Issue</h3></div></div></div>
	        
	
	       <p>
	        Analysis using an incoming batch is different than that of outgoing batches.  For incoming batches, you will rely on two tables,
	        <a href="data-model.html#table_incoming_batch" title="A.13.&nbsp;INCOMING_BATCH">INCOMING_BATCH</a> and  <a href="data-model.html#table_incoming_error" title="A.14.&nbsp;INCOMING_ERROR">INCOMING_ERROR</a>.
	
	       The first step in analyzing the cause of an incoming failed batch is to locate information about the batch, starting with
	       <a href="data-model.html#table_incoming_batch" title="A.13.&nbsp;INCOMING_BATCH">INCOMING_BATCH</a>
	        To locate batches in error, use:
	       </p><pre class="programlisting">select * from sym_incoming_batch where error_flag=1;</pre><p>
	       Several useful pieces of information are available from this query:
	       </p><div class="itemizedlist"><ul type="disc"><li>
	       The batch number of the failed batch, available in column <code class="literal">BATCH_ID</code>.  Note that this is the batch number of the
	       outgoing batch on the outgoing node.
	       </li><li>
	       The node the batch is being sent from, available in column <code class="literal">NODE_ID</code>.
	       </li><li>
	       The channel to which the batch belongs, available in column <code class="literal">CHANNEL_ID</code>.
	       All subsequent batches on this channel from this node will be held until the error condition is resolved.
	       </li><li>
	        The data_id that was being processed when the batch failed, available in column <code class="literal">FAILED_DATA_ID</code>.
	       </li><li>
	       Any SQL message, SQL State, and SQL Codes being returned during the synchronization attempt, available in columns <code class="literal">SQL_MESSAGE</code>,
	       <code class="literal">SQL_STATE</code>, and <code class="literal">SQL_CODE</code>, respectively.
	       </li></ul></div><p>
	       </p>
	
	       <p>
	       For incoming batches, we do not have data and data event entries in the database we can query.
	       We do, however, have a table,  <a href="data-model.html#table_incoming_error" title="A.14.&nbsp;INCOMING_ERROR">INCOMING_ERROR</a>, which provides some information about the batch.
	
	
	       </p><pre class="programlisting">select * from sym_incoming_error
	            where batch_id='XXXXXX' and node_id='YYYYY';</pre><p>
	       where XXXXXX is the batch id and YYYYY is the node id of the failing batch.
	
	
	       </p>
	
	         <p>
	       This query returns a wealth of information about each data change in a batch, including:
	       </p><div class="itemizedlist"><ul type="disc"><li>
	       The table involved in each data change, available in column <code class="literal">TARGET_TABLE_NAME</code>,</li><li>
	       The event type (Update [U], Insert [I], or Delete [D]), available in column <code class="literal">EVENT_TYPE</code>,
	       </li><li>
	       A comma separated list of the new data and (optionally) the old data, available in columns <code class="literal">ROW_DATA</code> and
	       <code class="literal">OLD_DATA</code>, respectively,</li><li>
	       The column names of the table, available in column <code class="literal">COLUMN_NAMES</code>,</li><li>
	       The primary key column names of the table, available in column <code class="literal">PK_COLUMN_NAMES</code>,</li></ul></div><p>
	       </p>
	
	
	    </div>
		<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manage-incoming-batches-resolving-issues"></a>4.5.2.&nbsp;Resolving the Issue</h3></div></div></div>
            

            <p>
            For batches in error, from the incoming side you'll also have to decide the best course of action to fix the issue.
            Incoming batch errors <span class="emphasis"><em>that are in conflict</em></span> can by fixed by taking advantage of two columns in <a href="data-model.html#table_incoming_error" title="A.14.&nbsp;INCOMING_ERROR">INCOMING_ERROR</a> which are examined each time
            batches are processed.  The first column, <code class="literal">resolve_data</code> if filled in will be used in place of <code class="literal">row_data</code>.
            The second column, <code class="literal">resolve_ignore</code> if set will cause this particular data item to be ignored and batch processing to continue.  This is the same
            two columns used when a manual conflict resolution strategy is chosen, as discussed in <a href="config.html#conflicts" title="3.7.1.&nbsp;Conflict Detection and Resolution">Section&nbsp;3.7.1, &#8220;Conflict Detection and Resolution&#8221;</a>.
            </p>
      	</div>
   	</div>
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manage-staging-area"></a>4.6.&nbsp;Staging Area</h2></div></div></div>
		
		<p>
        SymmetricDS creates temporary extraction and data load files with the CSV payload of a synchronization when
        the value of the <code class="literal">stream.to.file.threshold.bytes</code> SymmetricDS property has been reached.  Before reaching the threshold, files
        are streamed to/from memory.  The default threshold value is 32,767 bytes. This feature may be turned off by setting the <code class="literal">stream.to.file.enabled</code>
        property to false.
        </p>
        <p>
        SymmetricDS creates these temporary files in the directory specified by the <code class="literal">java.io.tmpdir</code> Java System property.
        </p>
        <p>
        The location of the temporary directory may be changed by setting the Java System property passed into the Java program at startup.  For example,
        </p><pre class="programlisting">
  -Djava.io.tmpdir=/home/.symmetricds/tmp
        </pre><p>
        </p>
	</div>
	<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manage-logging"></a>4.7.&nbsp;Logging</h2></div></div></div>
	
	    <p>
        The standalone SymmetricDS installation uses <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://logging.apache.org/log4j/1.2/index.html" target="_top">Log4J</a> for logging.  The configuration file is  <code class="literal">conf/log4j.xml</code>.
        The <code class="literal">log4j.xml</code> file has hints as to what logging can be enabled for useful, finer-grained logging.
        </p>
        <p>
        There is a command line option to turn on preconfigured debugging levels.  When the <code class="literal">--debug</code> option is used the <code class="literal">conf/debug-log4j.xml</code> is used instead of log4j.xml.
        </p>
        <p>
        SymmetricDS proxies all of its logging through <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/" target="_top">SLF4J</a>.  When deploying to an application server or if Log4J is not
        being leveraged, then the general rules for for SLF4J logging apply.
        </p>
	</div>
	
</div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="30%" align="left"><a accesskey="p" href="config.html">Prev</a>&nbsp;</td><td width="40%" align="center"><a accesskey="h" href="user-guide.html">Home</a></td><td width="30%" align="right">&nbsp;<a accesskey="n" href="advanced.html">Next</a></td></tr><tr><td width="30%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Configuration&nbsp;</td><td width="40%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.symmetricds.org/" title="SymmetricDS">SymmetricDS
                                        </a></span></td><td width="30%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Advanced Topics</td></tr></table></div></body></html>